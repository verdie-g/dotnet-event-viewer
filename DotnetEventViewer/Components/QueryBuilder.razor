@using System.Runtime.InteropServices
@using System.Text.RegularExpressions
@using DotnetEventViewer.CallTree.Decorators
@using DotnetEventViewer.Querying
@using DotnetEventViewer.Querying.Operators
@using DotnetEventViewer.State
@using EventPipe

@inject StateContainer State

<EditForm EditContext="_editContext" OnValidSubmit="@HandleValidSubmit" FormName="query-builder" novalidate>
    <FluentStack Orientation="Orientation.Vertical">

        @for (int i = 0; i < Query.Filters.Count; i += 1)
        {
            int idx = i;
            <div>
                <FluentStack Orientation="Orientation.Horizontal">
                    <FluentCombobox TOption="Field"
                                    Width="200px"
                                    Placeholder="Select the field to filter on"
                                    Items="GetFields(Query.Filters[idx])"
                                    OptionDisabled="f => IsFieldDisabled(f, Query.Filters[idx])"
                                    Autocomplete="ComboboxAutocomplete.Both"
                                    OptionText="@(f => f.Name)"
                                    @bind-SelectedOption="Query.Filters[idx].Field"
                                    Required />
                    @if (Query.Filters[idx].Field == Field.EventNameField)
                    {
                        <FluentSelect TOption="IOperator"
                                      Width="100px"
                                      Items="@([OneOfOperator.Instance])"
                                      OptionText="@(o => o.Text)"
                                      @bind-SelectedOption="Query.Filters[idx].Operator"/>
                        <FluentAutocomplete TOption="string"
                                            AutoComplete="off"
                                            Placeholder="Select event names"
                                            OnOptionsSearch="@OnEventNameSearch"
                                            MaximumSelectedOptions="3"
                                            @bind-SelectedOptions:get="@((string[])Query.Filters[idx].ParsedValue)"
                                            @bind-SelectedOptions:set="(IEnumerable<string>? v) => Query.Filters[idx].ParsedValue = v?.ToArray() ?? []" />
                    }
                    else
                    {
                        <FluentSelect TOption="IOperator"
                                      Width="100px"
                                      Items="AllOperators"
                                      OptionText="@(o => o.Text)"
                                      @bind-SelectedOption="Query.Filters[idx].Operator"/>
                        <FluentTextField @bind-Value="Query.Filters[idx].Value"
                                         Minlength="1"
                                         Required />
                    }
                    <FluentButton Title="Remove filter"
                                  IconStart="@(new Icons.Regular.Size24.Dismiss())"
                                  OnClick="_ => OnRemoveFilter(idx)" />
                </FluentStack>
                <FluentValidationMessage For="() => Query.Filters[idx]" />
            </div>
        }

        <FluentStack Orientation="Orientation.Horizontal">
            <FluentButton OnClick="@OnAddFilter"
                          IconStart="@(new Icons.Regular.Size24.Add())">
                Add Filter
            </FluentButton>
            @if (QueryType == QueryType.List)
            {
                <FluentAutocomplete TOption="Field"
                                    Width="500px"
                                    AutoComplete="off"
                                    Placeholder="Select column"
                                    OnOptionsSearch="@OnColumnFieldSearch"
                                    MaximumSelectedOptions="6"
                                    OptionText="@(f => f.Name)"
                                    @bind-SelectedOptions="_selectedColumnFields" />
            }
            else if (QueryType == QueryType.Tree)
            {
                <FluentSelect TOption="ICallTreeNodeDecorator"
                              Items="AllDecorators"
                              OptionText="@(d => d.Name)"
                              @bind-SelectedOption="_selectedDecorator" />
            }
            <FluentButton Type="ButtonType.Submit"
                          Appearance="Appearance.Accent"
                          IconStart="@(new Icons.Regular.Size24.ArrowSync())">
                Run query
            </FluentButton>
        </FluentStack>
    </FluentStack>
</EditForm>

@code
{
    private static readonly IOperator[] AllOperators =
    [
        EqualOperator.Instance,
        NotEqualOperator.Instance,
        LessOperator.Instance,
        LessOrEqualOperator.Instance,
        GreaterOperator.Instance,
        GreaterOrEqualOperator.Instance,
        MatchOperator.Instance,
        NotMatchOperator.Instance,
        OneOfOperator.Instance,
    ];

    private static readonly Field[] DefaultColumnFields =
    [
        Field.TimeStampField,
        Field.ThreadIdField,
        Field.EventNameField,
    ];

    private static readonly ICallTreeNodeDecorator[] AllDecorators =
    [
        EventsCountDecorator.Instance,
        AllocationSizeDecorator.Instance,
    ];

    private Field[] _allFields = [];
    private IEnumerable<Field>? _selectedColumnFields;
    private ICallTreeNodeDecorator? _selectedDecorator;
    private EditContext _editContext = default!;
    private ValidationMessageStore _messageStore = default!;

    [Parameter, EditorRequired]
    public QueryType QueryType { get; set; }

    [Parameter]
    public EventCallback<QueryResult> OnQuery { get; set; }

    [SupplyParameterFromForm]
    private Query Query { get; set; } = default!;

    protected override void OnInitialized()
    {
        _allFields = Field.StaticEventField
            .Concat(EnumerateDynamicFieldSelectors(State.Trace!))
            .OrderBy(s => s.Name)
            .ToArray();
        _selectedColumnFields = DefaultColumnFields;
        _selectedDecorator = EventsCountDecorator.Instance;
        Query = State.Query!;
        _editContext = new EditContext(Query);
        _editContext.OnValidationRequested += OnValidationRequested;
        _messageStore = new ValidationMessageStore(_editContext);
    }

    private IEnumerable<Field> EnumerateDynamicFieldSelectors(Trace trace)
    {
        return trace.EventMetadata
            .SelectMany(m => m.FieldDefinitions.Select(d => Field.FromPayloadFieldDefinition(d, m)))
            .DistinctBy(s => s.Name);
    }

    private void OnAddFilter()
    {
        Query.Filters.Add(new Filter(Field.ThreadIdField, EqualOperator.Instance, ""));
    }

    private void OnRemoveFilter(int idx)
    {
        Query.Filters.RemoveAt(idx);
    }

    private void OnEventNameSearch(OptionsSearchEventArgs<string> e)
    {
        e.Items = State.Trace!.EventMetadata
            .Select(m => m.EventName)
            .Distinct()
            .Where(n => n.Length != 0 && n.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
    }

    private IEnumerable<Field> GetFields(Filter forFilter)
    {
        if (forFilter.Field == Field.EventNameField)
        {
            return _allFields;
        }

        var eventNames = GetFilteredEventNames();
        if (eventNames == null || eventNames.Length == 0)
        {
            return _allFields;
        }

        return _allFields.Where(f => f.AssociatedEventMetadata == null
            || eventNames.Contains(f.AssociatedEventMetadata.EventName)).ToArray();
    }

    private bool IsFieldDisabled(Field field, Filter forFilter)
    {
        if (forFilter.Field == Field.EventNameField)
        {
            return false;
        }

        if (field == Field.EventNameField)
        {
            return GetFilteredEventNames() != null;
        }

        return false;
    }

    private string[]? GetFilteredEventNames()
    {
        var filter = Query.Filters.FirstOrDefault(f => f.Field == Field.EventNameField);
        return (string[]?)filter?.ParsedValue;
    }

    private void OnColumnFieldSearch(OptionsSearchEventArgs<Field> e)
    {
        var eventNames = GetFilteredEventNames();
        if (eventNames == null || eventNames.Length == 0)
        {
            e.Items = _allFields.Where(f => f.Name.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
        }
        else
        {
            e.Items = _allFields.Where(f =>
                (f.AssociatedEventMetadata == null || eventNames.Contains(f.AssociatedEventMetadata.EventName))
                && f.Name.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
        }
    }

    private void OnValidationRequested(object? sender, ValidationRequestedEventArgs e)
    {
        _messageStore.Clear();

        for (int i = 0; i < Query.Filters.Count; i += 1)
        {
            int idx = i;
            var filter = Query.Filters[idx];

            if (!filter.Operator.IsCompatible(filter.Field.Type))
            {
                _messageStore.Add(() => Query.Filters[idx], $"Operator {filter.Operator.Text} is not compatible with this field.");
            }

            if (filter.Field == Field.EventNameField)
            {
                // filter.ParsedValue should already be set. Do nothing.
            }
            else if (filter.Operator is MatchOperator or NotMatchOperator)
            {
                try
                {
                    filter.ParsedValue = new Regex(filter.Value);
                }
                catch
                {
                    _messageStore.Add(() => Query.Filters[idx], $"\"{filter.Value}\" is not a valid regex.");
                }
            }
            else if (TryParseFilterValue(filter.Field.Type, filter.Value, out object parsedValue))
            {
                filter.ParsedValue = parsedValue;
            }
            else
            {
                _messageStore.Add(() => Query.Filters[idx], $"\"{filter.Value}\" is not a valid {filter.Field.Type}.");
            }
        }
    }

    private bool TryParseFilterValue(TypeCode fieldType, string value, out object parsedValue)
    {
        bool ok;
        switch (fieldType)
        {
            case TypeCode.Boolean when value == "0":
                ok = true;
                parsedValue = false;
                break;
            case TypeCode.Boolean when value == "1":
                ok = true;
                parsedValue = true;
                break;
            case TypeCodeExtensions.Guid:
                ok = Guid.TryParse(value, out Guid guidValue);
                parsedValue = guidValue;
                break;
            default:
                try
                {
                    parsedValue = Convert.ChangeType(value, fieldType);
                    ok = true;
                }
                catch
                {
                    parsedValue = "";
                    ok = false;
                }
                break;
        }

        return ok;

    }

    private void HandleValidSubmit()
    {
        IReadOnlyList<Event> filteredEvents;
        if (Query.Filters.Count == 0)
        {
            filteredEvents = State.Trace!.Events;
        }
        else
        {
            filteredEvents = State.Trace!.Events
                .Where(evt => FilterEvent(evt, Query))
                .ToArray();
        }

        _ = OnQuery.InvokeAsync(new QueryResult(filteredEvents, _selectedColumnFields, _selectedDecorator));
    }

    private bool FilterEvent(Event evt, Query query)
    {
        foreach (var filter in CollectionsMarshal.AsSpan(query.Filters))
        {
            var operand = filter.Field.Selector(evt);
            if (!filter.Operator.Match(operand, filter.ParsedValue))
            {
                return false;
            }
        }

        return true;
    }

}