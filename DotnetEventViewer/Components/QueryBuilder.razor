@using System.Runtime.InteropServices
@using System.Text.RegularExpressions
@using DotnetEventViewer.CallTree.Decorators
@using DotnetEventViewer.Querying
@using DotnetEventViewer.Querying.Operators
@using DotnetEventViewer.State
@using EventPipe

@inject StateContainer State

<EditForm EditContext="_editContext" OnValidSubmit="@HandleValidSubmit" FormName="query-builder" novalidate>
    <FluentStack Orientation="Orientation.Vertical">

        <FluentAutocomplete TOption="string"
                            AutoComplete="off"
                            Placeholder="Select event names"
                            OnOptionsSearch="@OnEventNameSearch"
                            MaximumSelectedOptions="3"
                            @bind-SelectedOptions:get="Query.EventNames"
                            @bind-SelectedOptions:set="(IEnumerable<string>? v) => Query.EventNames = v!.ToArray()"
                            Width="521px" />

        @for (int i = 0; i < Query.Filters.Length; i += 1)
        {
            int idx = i;
            <div>
                <FluentStack Orientation="Orientation.Horizontal">
                    <FluentCombobox TOption="Field"
                                    Width="200px"
                                    Placeholder="Select the field to filter on"
                                    Items="GetFields(Query.Filters[idx])"
                                    Autocomplete="ComboboxAutocomplete.Both"
                                    OptionText="@(f => f.Name)"
                                    @bind-SelectedOption="Query.Filters[idx].Field"
                                    Required/>
                    <FluentSelect TOption="IOperator"
                                  Width="80px"
                                  Items="AllOperators"
                                  OptionText="@(o => o.Text)"
                                  @bind-SelectedOption="Query.Filters[idx].Operator"/>
                    <FluentTextField @bind-Value="Query.Filters[idx].Value"
                                     Minlength="1"
                                     Required/>
                    <FluentButton Title="Remove filter"
                                  IconStart="@(new Icons.Regular.Size24.Dismiss())"
                                  OnClick="_ => OnRemoveFilter(idx)"/>
                </FluentStack>
                <FluentValidationMessage For="() => Query.Filters[idx]"/>
            </div>
        }

        <FluentStack Orientation="Orientation.Horizontal">
            <FluentButton OnClick="@OnAddFilter"
                          IconStart="@(new Icons.Regular.Size24.Add())">
                Add Filter
            </FluentButton>
            @if (QueryType == QueryType.List)
            {
                <FluentAutocomplete TOption="Field"
                                    Width="500px"
                                    AutoComplete="off"
                                    Placeholder="Select column"
                                    OnOptionsSearch="@OnColumnFieldSearch"
                                    MaximumSelectedOptions="6"
                                    OptionText="@(f => f.Name)"
                                    @bind-SelectedOptions="Query.SelectedColumnFields"/>
            }
            else if (QueryType == QueryType.Tree)
            {
                <FluentSelect TOption="ICallTreeNodeDecorator"
                              Items="AllDecorators"
                              OptionText="@(d => d.Name)"
                              @bind-SelectedOption="Query.SelectedDecorator"/>
                <FluentCheckbox
                    Id="tp-stacks-only"
                    Label="Thread Pool Stacks Only"
                    Style="margin-top: 6px"
                    @bind-Value="Query.ThreadPoolStacksOnly" />
                <FluentTooltip Anchor="tp-stacks-only">
                    Tries to filter out events that occured on a non-threadpool thread. Useful to investigate thread
                    pool starvation. This option is not 100% accurate.
                </FluentTooltip>
            }
            <FluentButton Type="ButtonType.Submit"
                          Appearance="Appearance.Accent"
                          IconStart="@(new Icons.Regular.Size24.ArrowSync())">
                Run query
            </FluentButton>
        </FluentStack>
    </FluentStack>
</EditForm>

@code
{
    private static readonly IOperator[] AllOperators =
    [
        EqualOperator.Instance,
        NotEqualOperator.Instance,
        LessOperator.Instance,
        LessOrEqualOperator.Instance,
        GreaterOperator.Instance,
        GreaterOrEqualOperator.Instance,
        MatchOperator.Instance,
        NotMatchOperator.Instance,
    ];

    private static readonly Field[] DefaultColumnFields =
    [
        Field.TimeStampField,
        Field.ThreadIdField,
        Field.EventNameField,
    ];

    private static readonly ICallTreeNodeDecorator[] AllDecorators =
    [
        EventsCountDecorator.Instance,
        AllocationSizeDecorator.Instance,
    ];

    private Field[] _allFields = [];
    private EditContext _editContext = default!;
    private ValidationMessageStore _messageStore = default!;

    [Parameter, EditorRequired]
    public QueryType QueryType { get; set; }

    [Parameter]
    public EventCallback<QueryResult> OnQuery { get; set; }

    [SupplyParameterFromForm]
    private Query Query { get; set; } = default!;

    protected override void OnInitialized()
    {
        _allFields = Field.StaticEventField
            .Concat(EnumerateDynamicFieldSelectors(State.Trace!))
            .OrderBy(s => s.Name)
            .ToArray();
        Query = State.Query!;
        Query.SelectedColumnFields ??= DefaultColumnFields;
        Query.SelectedDecorator ??= EventsCountDecorator.Instance;
        _editContext = new EditContext(Query);
        _editContext.OnValidationRequested += OnValidationRequested;
        _messageStore = new ValidationMessageStore(_editContext);
    }

    private IEnumerable<Field> EnumerateDynamicFieldSelectors(Trace trace)
    {
        return trace.EventMetadata
            .SelectMany(m => m.FieldDefinitions.Select(d => Field.FromPayloadFieldDefinition(d, m)))
            .DistinctBy(s => s.Name);
    }

    private void OnAddFilter()
    {
        var newFilters = new Filter[Query.Filters.Length + 1];
        Array.Copy(Query.Filters, newFilters, Query.Filters.Length);
        newFilters[^1] = new Filter(Field.ThreadIdField, EqualOperator.Instance, "");
        Query.Filters = newFilters;
    }

    private void OnRemoveFilter(int idx)
    {
        var newFilters = new Filter[Query.Filters.Length - 1];
        Array.Copy(Query.Filters, newFilters, newFilters.Length);
        Query.Filters = newFilters;
    }

    private void OnEventNameSearch(OptionsSearchEventArgs<string> e)
    {
        e.Items = State.Trace!.EventMetadata
            .Select(m => m.EventName)
            .Distinct()
            .Where(n => n.Length != 0 && n.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
    }

    private IEnumerable<Field> GetFields(Filter forFilter)
    {
        if (Query.EventNames.Length == 0)
        {
            return _allFields;
        }

        return _allFields.Where(f => f.AssociatedEventMetadata == null
            || Query.EventNames.Contains(f.AssociatedEventMetadata.EventName)).ToArray();
    }

    private void OnColumnFieldSearch(OptionsSearchEventArgs<Field> e)
    {
        if (Query.EventNames.Length == 0)
        {
            e.Items = _allFields.Where(f => f.Name.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
        }
        else
        {
            e.Items = _allFields.Where(f =>
                (f.AssociatedEventMetadata == null || Query.EventNames.Contains(f.AssociatedEventMetadata.EventName))
                && f.Name.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
        }
    }

    private void OnValidationRequested(object? sender, ValidationRequestedEventArgs e)
    {
        _messageStore.Clear();

        for (int i = 0; i < Query.Filters.Length; i += 1)
        {
            int idx = i;
            var filter = Query.Filters[idx];

            if (!filter.Operator.IsCompatible(filter.Field.Type))
            {
                _messageStore.Add(() => Query.Filters[idx], $"Operator {filter.Operator.Text} is not compatible with this field.");
            }

            if (filter.Field == Field.EventNameField)
            {
                // filter.ParsedValue should already be set. Do nothing.
            }
            else if (filter.Operator is MatchOperator or NotMatchOperator)
            {
                try
                {
                    filter.ParsedValue = new Regex(filter.Value);
                }
                catch
                {
                    _messageStore.Add(() => Query.Filters[idx], $"\"{filter.Value}\" is not a valid regex.");
                }
            }
            else if (TryParseFilterValue(filter.Field.Type, filter.Value, out object parsedValue))
            {
                filter.ParsedValue = parsedValue;
            }
            else
            {
                _messageStore.Add(() => Query.Filters[idx], $"\"{filter.Value}\" is not a valid {filter.Field.Type}.");
            }
        }
    }

    private bool TryParseFilterValue(TypeCode fieldType, string value, out object parsedValue)
    {
        bool ok;
        switch (fieldType)
        {
            case TypeCode.Boolean when value == "0":
                ok = true;
                parsedValue = false;
                break;
            case TypeCode.Boolean when value == "1":
                ok = true;
                parsedValue = true;
                break;
            case TypeCodeExtensions.Guid:
                ok = Guid.TryParse(value, out Guid guidValue);
                parsedValue = guidValue;
                break;
            default:
                try
                {
                    parsedValue = Convert.ChangeType(value, fieldType);
                    ok = true;
                }
                catch
                {
                    parsedValue = "";
                    ok = false;
                }
                break;
        }

        return ok;

    }

    private void HandleValidSubmit()
    {
        IReadOnlyList<Event> filteredEvents;
        if (Query.EventNames.Length == 0 && Query.Filters.Length == 0)
        {
            filteredEvents = State.Trace!.Events;
        }
        else
        {
            filteredEvents = State.Trace!.Events
                .Where(evt => FilterEvent(evt, Query))
                .ToArray();
        }

        _ = OnQuery.InvokeAsync(new QueryResult(filteredEvents, Query.SelectedColumnFields, Query.SelectedDecorator));
    }

    private bool FilterEvent(Event evt, Query query)
    {
        if (query.EventNames.Length != 0
            && Array.IndexOf(query.EventNames, evt.Metadata.EventName) == -1)
        {
            return false;
        }

        foreach (var filter in query.Filters)
        {
            var operand = filter.Field.Selector(evt);
            if (!filter.Operator.Match(operand, filter.ParsedValue))
            {
                return false;
            }
        }

        if (Query.ThreadPoolStacksOnly)
        {
            var frames = evt.StackTrace.Frames;
            if (frames.Length == 0
                || (frames[^1].Namespace == "System.Threading.Thread" && frames[^1].Name == "StartCallback"))
            {
                return false;
            }
        }

        return true;
    }

}