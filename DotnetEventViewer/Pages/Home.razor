@page "/"
@using DotnetEventViewer.State
@using EventPipe
@using DotnetEventViewer.Models
@using DotnetEventViewer.Querying
@using DotnetEventViewer.Querying.Operators

@layout HomeLayout

@inject StateContainer StateContainer
@inject NavigationManager NavigationManager

<PageTitle>.NET Event Viewer</PageTitle>

<h1>.NET Event Viewer</h1>

<p>
    This project is a modern <a href="https://github.com/microsoft/perfview" target="_blank">PerfView</a> alternative to
    analysis nettrace files collected from the .NET runtime's <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/eventpipe" target="_blank">EventPipe</a>
    or through the tool <a href="https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-trace" target="_blank">dotnet-trace</a>.
</p>

<p>
    This analysis tool is compiled to WebAssembly, ensuring that everything runs within your browser, and trace files
    remain confined to it. You can check out the code on <a href="https://github.com/verdie-g/dotnet-event-viewer" target="_blank">GitHub</a>.
</p>

<FluentInputFile Id="input-nettrace-file"
                 Mode="InputFileMode.Stream"
                 MaximumFileCount="1"
                 MaximumFileSize="@(1*1024*1024*1024)"
                 Accept=".nettrace"
                 @bind-ProgressPercent="@_progressPercent"
                 OnFileUploaded="@OnFileUploadedAsync"
                 Style="height: 300px; border: 1px dashed var(--accent-fill-rest);">
    <ChildContent>
        <label for="input-nettrace-file">
            <FluentIcon Value="@(new Icons.Regular.Size24.ArrowUpload())" />
        </label>

        <div>
            Drag nettrace file here you wish to analyze, or <label for="input-nettrace-file">browse</label> for it.
            <br />
            <em>Files never exit your browser.</em>
        </div>
    </ChildContent>
</FluentInputFile>

@code {
    private int _progressPercent;

    private async Task OnFileUploadedAsync(FluentInputFileEventArgs inputFile)
    {
        EventPipeReader reader = new(inputFile.Stream!);
        reader.AddProgress(new Progress<EventPipeReader.Progression>(p =>
        {
            int progressPercent = (int)(100f * p.BytesRead / inputFile.Size);
            if (progressPercent == _progressPercent)
            {
                return;
            }

            _progressPercent = progressPercent;
            StateHasChanged();
        }));
        StateContainer.Trace = await reader.ReadFullTraceAsync();
        StateContainer.TraceExtraMetadata = CreateTraceExtraMetadata(inputFile.Name, StateContainer.Trace);
        StateContainer.Query = CreateInitialQuery(StateContainer.Trace);

        NavigationManager.NavigateTo("list");
    }

    private TraceExtraMetadata CreateTraceExtraMetadata(string filename, Trace trace)
    {
        const string processInfoProviderName = "Microsoft-DotNETCore-EventPipe";
        const int processInfoEventId = 1;
        var processInfoEvent = trace.Events.FirstOrDefault(e =>
            e.Metadata is { EventId: processInfoEventId, ProviderName: processInfoProviderName });
        string commandLine = "";
        string osFamily = "";
        if (processInfoEvent != null)
        {
            commandLine = (string)processInfoEvent.Payload["CommandLine"];
            osFamily = (string)processInfoEvent.Payload["OSInformation"];
        }

        const string runtimeInfoProviderName = "Microsoft-Windows-DotNETRuntimeRundown";
        const int runtimeInfoEventId = 187;
        var runtimeInfoEvent = trace.Events.FirstOrDefault(e =>
            e.Metadata is { EventId: runtimeInfoEventId, ProviderName: runtimeInfoProviderName });
        Version runtimeVersion = new(0, 0);
        if (runtimeInfoEvent != null)
        {
            ushort runtimeMajorVersion = (ushort)runtimeInfoEvent.Payload["BclMajorVersion"];
            ushort runtimeMinorVersion = (ushort)runtimeInfoEvent.Payload["BclMinorVersion"];
            ushort runtimeBuildNumber = (ushort)runtimeInfoEvent.Payload["BclBuildNumber"];
            runtimeVersion = new Version(runtimeMajorVersion, runtimeMinorVersion, runtimeBuildNumber);
        }

        // The events are sorted by timestamp so the duration is the timestamp of the last event.
        var duration = TimeSpan.FromTicks(trace.Events[^1].TimeStamp / TimeSpan.NanosecondsPerTick);

        return new TraceExtraMetadata(filename, commandLine, osFamily, runtimeVersion, duration);
    }

    private Query CreateInitialQuery(Trace trace)
    {
        var metadata = trace.EventMetadata.FirstOrDefault(m =>
            m.ProviderName != "Microsoft-Windows-DotNETRuntimeRundown"
            && m.EventName.Length != 0);
        if (metadata == null)
        {
            return new Query { Filters = [] };
        }

        return new Query
        {
            Filters = [new Filter(Field.EventNameField, OneOfOperator.Instance, metadata.EventName)
            {
                ParsedValue = new[] { metadata.EventName },
            }],
        };
    }
}