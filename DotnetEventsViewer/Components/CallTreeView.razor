@using DotnetEventsViewer.CallTree
@using DotnetEventsViewer.CallTree.CountAggregators
@using EventPipe

@if (_tree != null && Aggregator != null)
{
    <FluentTreeView>
        @RenderCallTreeNode(_tree)
    </FluentTreeView>
}

@code
{
    // Ids of the rendered nodes. Only contain the leaves of the rendered tree.
    private readonly HashSet<int> _treeRenderedLeafIds = [];
    // Ids of the expanded nodes. Must be saved because the info is lost when the nodes get closed/destroyed.
    private readonly HashSet<int> _expandedNodes = [];
    private CallTreeNode? _tree;

    [Parameter]
    public CallTreeNode? Tree { get; set; }

    [Parameter]
    public ICallTreeCountAggregator? Aggregator { get; set; }

    protected override void OnParametersSet()
    {
        if (Tree != _tree)
        {
            _tree = Tree;
            _treeRenderedLeafIds.Clear();
            _treeRenderedLeafIds.Add(_tree!.Id);
            _expandedNodes.Clear();
        }
    }

    private void OnNodeExpanded(CallTreeNode node, bool expanded)
    {
        if (expanded)
        {
            _treeRenderedLeafIds.Remove(node.Id);
            _expandedNodes.Add(node.Id);

            var n = node;
            while (n.Children is { Count: 1 })
            {
                n = n.Children.First().Value;
                _expandedNodes.Add(n.Id);
            }

            if (n.Children != null)
            {
                foreach (var child in n.Children!)
                {
                    _treeRenderedLeafIds.Add(child.Value.Id);
                }
            }
        }
        else
        {
            _expandedNodes.Remove(node.Id);
            _treeRenderedLeafIds.Add(node.Id);
        }
    }

    private RenderFragment RenderCallTreeNode(CallTreeNode node, CallTreeNode? parent = null, bool renderChildren = true)
    {
        return builder =>
        {
            // Render at least a single child so the expand button is available.
            bool renderFirstChildOnly = _treeRenderedLeafIds.Contains(node.Id);
            bool expandNode = _expandedNodes.Contains(node.Id) && !renderFirstChildOnly;
            builder.OpenComponent<FluentTreeItem>(0);
            builder.AddAttribute(1, nameof(FluentTreeItem.Text), GenerateNodeText(_tree!, node));
            EventCallback<bool> expandedChanged = new EventCallback<bool>(this, (bool e) => OnNodeExpanded(node, e));
            builder.AddAttribute(2, nameof(FluentTreeItem.ExpandedChanged), expandedChanged);
            builder.AddAttribute(3, nameof(FluentTreeItem.Expanded), expandNode);

            if (node.Children != null)
            {
                builder.AddAttribute(4, nameof(FluentTreeItem.ChildContent), (RenderFragment)(b =>
                {
                    if (!renderChildren)
                    {
                        return;
                    }

                    if (renderFirstChildOnly)
                    {
                        var firstChild = node.Children.Values.OrderByDescending(n => n.Count).First();
                        RenderCallTreeNode(firstChild, node, renderChildren: false)(b);
                        return;
                    }

                    foreach (var child in node.Children.Values.OrderByDescending(n => n.Count))
                    {
                        RenderCallTreeNode(child, node)(b);
                    }
                }));
            }

            builder.CloseComponent();
        };
    }

    private string GenerateNodeText(CallTreeNode root, CallTreeNode node)
    {
        float ratio = node.Count / (float)root.Count;
        return $"({100 * ratio:0.00}% - {Aggregator!.Format(node.Count)}) {node.MethodDescription}";
    }
}